---
description:
globs:
alwaysApply: true
---
ğŸš€ NISTO Migration Guide (PyQt5 â†’ React + FastAPI)
1. Core Migration Strategy

Main Window

PyQt5 MainWindow â†’ React App.jsx (main layout)

Menus â†’ React components with React Router for navigation

Dialogs â†’ Forms

PyQt5 dialogs (QDialog) â†’ React controlled forms (<form>, <input>, <button>)

Event handlers â†’ React onClick, onChange

Properties Panel

PyQt5 sidebar â†’ React sidebar component

Property editing â†’ Controlled React form + live state updates

Real-time updates â†’ React useState + API calls

2. Feature Mapping (MVP First)

Device Management

Backend: CRUD API in FastAPI (/devices)

Frontend: DeviceList.jsx + DeviceForm.jsx

Connection Management

Backend: CRUD API (/connections)

Frontend: ConnectionList.jsx + ConnectionForm.jsx

Property Management

Backend: update properties API

Frontend: PropertyEditor.jsx

Undo/Redo

PyQt5 undo_redo_manager â†’ Redux/Context state history

React buttons (Undo, Redo) dispatch state actions

UI Framework

PyQt5 layouts â†’ React components + CSS (Flexbox/Grid)

Icons/resources â†’ public/icons/ served to React

3. Event Handling

Signals/Slots (Qt) â†’ useState, useEffect in React

Event Bus â†’ Context API or Redux for global state

Component Communication â†’ props drilling or context

4. Data Flow

PyQt5: Imperative (widget.setText("x"))

React: Declarative (setState("x") â†’ UI updates automatically)

Data flows down via props, updates up via callbacks

5. Mode Management

PyQt5 mode manager â†’ React Router routes (e.g., /edit, /view)

Render different components based on current route/state

âš–ï¸ Key Differences: PyQt5 vs React
PyQt5 (Desktop)	React (Web)
Imperative updates (manually change widget properties)	Declarative rendering (UI = function of state)
Signals/slots	Hooks (useState, useEffect)
Event bus	Redux / Context API
Layouts (QVBox/QHBox/Grid)	CSS Flexbox / Grid
Dialogs	Forms & Modals
Modes (via manager class)	Routes (React Router)

ğŸ‘‰ This guide is your translation playbook:

Start with MVP features (devices, connections, properties, undo/redo).

Translate PyQt5 widgets/dialogs into React components.

Map signals/slots â†’ hooks, event bus â†’ Redux/Context.

Use FastAPI for backend CRUD, React for state/UI.

Do you want me to make a small side-by-side example (PyQt5 dialog â†’ React form) so you can see exactly how the translation looks in code?

You said:
give me a through instruction sheet to prompt cursor to start making the transition
ChatGPT said:

Awesomeâ€”hereâ€™s a copy-paste â€œCursor Mission Briefâ€ you can drop into a new Cursor chat to kick off the PyQt5 â†’ Web migration. Itâ€™s written so Cursor will scaffold the repo, generate code, and iterate in small, testable steps.

ğŸ§  Cursor Mission Brief: NISTO (PyQt5 â†’ FastAPI + React)

You are an expert full-stack engineer. Your job is to migrate a desktop PyQt5 network-topology tool (â€œNISTOâ€) into a web app (FastAPI + React) with a focused MVP.

ğŸ¯ MVP Scope (Phase 1)

Implement the core workflow only:

Devices: create, list, edit, delete, basic config fields

Connections: create, list, edit, delete (link two devices, type, properties)

Properties: edit device/connection properties in a sidebar

Undo/Redo: client-side history for device/connection CRUD + property edits

Basic UI: main layout, top nav, simple forms/dialogs, list views

Health: /healthz endpoint, simple logging

Embed-Ready: allow iframe embedding in Notion

Defer: clipboard, bulk ops, multi-mode editing, alignment tools, boundary shapes, advanced dialogs.

ğŸ§± Target Folder Structure
NISTO_WEB/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”œâ”€â”€ api.py
â”‚   â”‚   â”œâ”€â”€ models.py        # SQLAlchemy
â”‚   â”‚   â”œâ”€â”€ schemas.py       # Pydantic
â”‚   â”‚   â”œâ”€â”€ crud.py
â”‚   â”‚   â”œâ”€â”€ db.py
â”‚   â”‚   â”œâ”€â”€ deps.py
â”‚   â”‚   â””â”€â”€ utils.py
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ test_devices.py
â”‚   â”‚   â””â”€â”€ test_connections.py
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ public/
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ api/axios.ts
â”‚       â”œâ”€â”€ store/ (Redux Toolkit)
â”‚       â”‚   â”œâ”€â”€ index.ts
â”‚       â”‚   â”œâ”€â”€ devicesSlice.ts
â”‚       â”‚   â”œâ”€â”€ connectionsSlice.ts
â”‚       â”‚   â””â”€â”€ undoRedoMiddleware.ts
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ DeviceList.tsx
â”‚       â”‚   â”œâ”€â”€ DeviceForm.tsx
â”‚       â”‚   â”œâ”€â”€ ConnectionList.tsx
â”‚       â”‚   â”œâ”€â”€ ConnectionForm.tsx
â”‚       â”‚   â””â”€â”€ PropertyEditor.tsx
â”‚       â”œâ”€â”€ pages/
â”‚       â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚       â”‚   â””â”€â”€ NotFound.tsx
â”‚       â”œâ”€â”€ App.tsx
â”‚       â””â”€â”€ main.tsx
â”œâ”€â”€ deploy/
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â”œâ”€â”€ nginx.conf
â”‚   â””â”€â”€ README.md
â””â”€â”€ README.md

ğŸ“¦ Tech & Conventions

Backend: Python 3.11, FastAPI, SQLAlchemy, Uvicorn, Pydantic v2, Alembic (optional later), SQLite for dev (Postgres ready)

Frontend: React + Vite + TypeScript, Redux Toolkit, React Router

Styling: CSS Modules (keep simple; Tailwind can be added later if needed)

Testing: pytest (backend), vitest/react-testing-library (frontend)

API style: RESTful /{resource} with pagination later

Commit cadence: small, test-backed commits; include brief rationale

ğŸ—‚ï¸ Data Model (MVP)

Device

id: int (PK)

name: str (required)

type: str (switch/router/server/workstation/generic)

x: float, y: float (optional for future canvas)

config: JSON (dict of simple key/values)

Connection

id: int (PK)

source_device_id: int (FK -> devices.id)

target_device_id: int (FK -> devices.id)

link_type: str (ethernet/fiber/vpn/etc.)

properties: JSON

Rules

Prevent self-loop unless allow_self_link=true (not in MVP)

Basic referential integrity; cascade deletes: deleting a device deletes its connections

ğŸ”Œ API Endpoints (MVP)

Devices

GET /api/devices â†’ list

POST /api/devices â†’ create

GET /api/devices/{id} â†’ detail

PUT /api/devices/{id} â†’ update

DELETE /api/devices/{id} â†’ delete

Connections

GET /api/connections

POST /api/connections

GET /api/connections/{id}

PUT /api/connections/{id}

DELETE /api/connections/{id}

Health

GET /healthz â†’ { "status": "ok" }

All POST/PUT validate with Pydantic schemas; return 422 on invalid input.

ğŸ” Embedding in Notion (Required)

FastAPI middleware: set headers

Content-Security-Policy: frame-ancestors 'self' https://www.notion.so https://notion.so;

Do not set X-Frame-Options: DENY (omit or set to ALLOWALL)

CORS: allow frontend origin in dev, restrict in prod

Nginx (prod): preserve CSP above

ğŸ§ª Acceptance Criteria (Phase 1)

docker-compose up starts backend, frontend, and nginx proxy locally

Visiting http://localhost shows Dashboard with:

Device list + â€œAdd Deviceâ€ form (create/edit/delete)

Connection list + â€œAdd Connectionâ€ form (create/edit/delete)

Property sidebar tied to selected device/connection

Undo/Redo buttons that revert/apply last change (client-side)

All API routes reachable under /api/*

GET /healthz returns 200 JSON

Basic backend tests pass: pytest

Basic frontend tests pass: pnpm test (or npm/yarn)

ğŸ§­ Step-By-Step Tasks (Generate Code for Each Step)
Step 0 â€” Repo Init

Create NISTO_WEB/ and subfolders per structure above.

Add root README.md with project overview, run instructions, and MVP scope.

Step 1 â€” Backend Scaffold

Create FastAPI app with:

main.py (app init, CORS, CSP headers, /healthz)

db.py (SQLAlchemy engine/session; SQLite dev DB)

models.py (Device, Connection)

schemas.py (DeviceCreate/Update/Read; ConnectionCreate/Update/Read)

crud.py (CRUD fns)

api.py (APIRouter for /devices, /connections)

Wire routers in main.py under /api.

requirements.txt with fastapi, uvicorn, sqlalchemy, pydantic, python-multipart, pytest.

Add backend/tests/test_devices.py and test_connections.py with: create â†’ list â†’ update â†’ delete happy paths + 422/404 cases.

Add Makefile or poetry optional (skip if slower).

Definition of Done: uvicorn app.main:app runs; tests green with pytest -q.

Step 2 â€” Frontend Scaffold

Initialize Vite React + TS app in frontend/.

Install: react-router-dom, @reduxjs/toolkit, react-redux, axios, vitest, @testing-library/react.

Add api/axios.ts with baseURL /api.

Configure store with devicesSlice, connectionsSlice; add undoRedoMiddleware.

Add pages and components with minimal styling:

Dashboard.tsx: two columns

Left pane: DeviceList + â€œAdd/Edit Deviceâ€ modal

Middle pane: ConnectionList + â€œAdd/Edit Connectionâ€ modal

Right pane: PropertyEditor (shows fields based on selection)

Top bar: Undo / Redo buttons (disabled when no history)

Add routes in App.tsx:

/ â†’ Dashboard

* â†’ NotFound

Definition of Done: App loads, can CRUD devices/connections, edit props, undo/redo last action.

Step 3 â€” Undo/Redo (Client-Side)

Use Redux Toolkit:

Keep a history stack of past states (devices, connections, selectedId, properties panel state).

Limit to last 50 steps.

Push on successful actions: create/update/delete device/connection, property edit, selection change.

UNDO pops a state; REDO reapplies.

Do not persist history to backend (MVP).

Definition of Done: Clicking Undo/Redo updates UI predictably across CRUD/property edits.

Step 4 â€” Notion Embed

Add CSP middleware in backend:

frame-ancestors 'self' https://www.notion.so https://notion.so

Confirm embedded view renders at app root.

Add an /embed route (frontend) that mounts the dashboard in a single-column layout (narrower min-height), no external nav.

Definition of Done: Pasting app URL into a Notion â€œ/embedâ€ block renders the interactive app.

Step 5 â€” Docker & Proxy

docker-compose.yml with services:

backend: uvicorn app.main:app --host 0.0.0.0 --port 8000

frontend: vite dev or nginx serving built files (for prod)

nginx: reverse proxy /: frontend, /api/: backend

deploy/nginx.conf honors CSP header upstream; adds gzip, basic security headers.

Update README with:

Dev: run backend + frontend separately OR via compose

Prod: vite build â†’ serve static via nginx, proxy /api

Definition of Done: docker-compose up yields a working full stack at http://localhost.

ğŸ§° Sample Commands (for CI sanity)

Backend:

python -m venv .venv && source .venv/bin/activate && pip install -r backend/requirements.txt

pytest -q backend/tests

Frontend:

cd frontend && pnpm i && pnpm dev

pnpm test

Compose:

docker-compose up --build

ğŸ“ Coding Standards

Type-annotate Python; enable strict mypy later

Keep slices small and pure; side effects in thunks/middleware

Catch and surface API errors (toast or inline error)

Small, focused components; lift state into Redux only if shared

Every PR includes a short checklist: what/why/how tested

ğŸ§ª Minimal Test Cases (must implement)

Devices API: create (201), list (200), update (200), delete (204), get(404) after delete, invalid payload (422)

Connections API: same; plus creating with invalid device ids (400)

Frontend:

Render lists; add device; edit device; delete device

Create connection between two existing devices

Change a property in sidebar; verify it reflects in list

Undo then Redo returns to prior state

ğŸ” PyQt5 â†’ React Mapping (for reference)

MainWindow â†’ App.tsx + Router

Dialogs (QDialog) â†’ Controlled React Forms/Modals

Signals/Slots â†’ useState, useEffect, Redux actions

EventBus â†’ Redux/Context

Layouts (QHBox/VBox/Grid) â†’ CSS Flexbox/Grid

Imperative widget updates â†’ Declarative state rendering

â­ï¸ Start Now (first actions)

Scaffold backend per Step 1; run uvicorn and pass tests.

Scaffold frontend per Step 2; hard-code against a mocked API first, then wire real API.

Add undo/redo middleware and buttons.

Add CSP middleware for Notion embedding.

Add docker-compose and nginx.

At each step: show me generated files, explain choices, and run tests.

ğŸ“ Extras (optional after MVP)

Migrate SQLite â†’ Postgres; add Alembic

Add auth (JWT), projects/multi-tenant data

Canvas positions (x,y) and visual editor

Bulk actions, alignment tools, boundary shapes

End of brief.
Please proceed step-by-step, generating code and tests exactly to this spec. If anything is ambiguous, choose the simplest, testable option and document it in the README.